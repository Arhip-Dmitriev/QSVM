import numpy as np
import warnings
from sklearn.datasets import make_circles
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from qiskit import QuantumCircuit, pulse
from qiskit.pulse import Gaussian, Drag, GaussianSquare
from qiskit_ibm_runtime.fake_provider import FakeManilaV2
from qiskit.primitives import BackendSamplerV2

warnings.filterwarnings("ignore", category=DeprecationWarning)

backend = FakeManilaV2()

def apply_pulse_calibrations(qc, data, n_qubits):
    for i in range(n_qubits):
        with pulse.build(backend, name=f"h_pulse_{i}") as h_sched:
            d_chan = pulse.drive_channel(i)
            pulse.play(Drag(duration=160, amp=0.1, sigma=40, beta=0.5), d_chan)
        qc.add_calibration('h', [i], h_sched)

        with pulse.build(backend, name=f"p_pulse_{i}") as p_sched:
            pulse.shift_phase(2.0 * data[i], pulse.drive_channel(i))
        qc.add_calibration('p', [i], p_sched, [2.0 * data[i]])

    for i in range(n_qubits - 1):
        with pulse.build(backend, name=f"zz_pulse_{i}") as zz_sched:
            try:
                c_chan = pulse.control_channels(i, i+1)[0]
            except:
                c_chan = pulse.drive_channel(i)
            d_chan = pulse.drive_channel(i)
            
            duration, amp, sigma = 512, 0.2, 64
            width = duration - 4 * sigma
            
            pulse.play(GaussianSquare(duration=duration, amp=amp, sigma=sigma, width=width), c_chan)
            pulse.play(Gaussian(duration=160, amp=0.1, sigma=40), d_chan)
            pulse.play(GaussianSquare(duration=duration, amp=-amp, sigma=sigma, width=width), c_chan)
            pulse.play(Gaussian(duration=160, amp=0.1, sigma=40), d_chan)

        phi = 2.0 * (np.pi - data[i]) * (np.pi - data[i+1])
        qc.rzz(phi, i, i+1)
        qc.add_calibration('rzz', [i, i+1], zz_sched, [phi])
    
    return qc

def compute_kernel_matrix(X_train, X_test):
    n_samples_1 = len(X_train)
    n_samples_2 = len(X_test)
    n_qubits = X_train.shape[1]
    kernel_matrix = np.zeros((n_samples_1, n_samples_2))
    
    sampler = BackendSamplerV2(backend=backend)
    circuits = []
    
    for i in range(n_samples_1):
        for j in range(n_samples_2):
            qc = QuantumCircuit(n_qubits)
            
            qc.h(range(n_qubits))
            for k in range(n_qubits): qc.p(2.0 * X_train[i][k], k)
            apply_pulse_calibrations(qc, X_train[i], n_qubits)
            
            fm_j_inv = QuantumCircuit(n_qubits)
            fm_j_inv.h(range(n_qubits))
            for k in range(n_qubits): fm_j_inv.p(2.0 * X_test[j][k], k)
            apply_pulse_calibrations(fm_j_inv, X_test[j], n_qubits)
            
            qc.compose(fm_j_inv.inverse(), inplace=True)
            qc.measure_all()
            circuits.append(qc)

    batch_size = 10
    for k in range(0, len(circuits), batch_size):
        batch = circuits[k:k+batch_size]
        job = sampler.run(batch)
        results = job.result()
        
        for idx, res in enumerate(results):
            global_idx = k + idx
            row = global_idx // n_samples_2
            col = global_idx % n_samples_2
            counts = res.data.meas.get_counts()
            shots = sum(counts.values())
            prob = counts.get("0" * n_qubits, 0) / shots
            kernel_matrix[row, col] = prob

    return kernel_matrix

X, y = make_circles(n_samples=15, noise=0.05, factor=0.4)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

print("Computing Quantum Kernel Matrix (Pulse-Level)...")
kernel_train = compute_kernel_matrix(X_train, X_train)
kernel_test = compute_kernel_matrix(X_test, X_train)

svm = SVC(kernel="precomputed")
svm.fit(kernel_train, y_train)
predictions = svm.predict(kernel_test)

print("\n--- QSVM RESULTS ---")
print(f"Accuracy: {np.mean(predictions == y_test) * 100:.2f}%")
print(f"Predictions: {predictions}")
print(f"Actual:      {y_test}")
