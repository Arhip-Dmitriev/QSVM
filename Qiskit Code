import numpy as np
from sklearn.datasets import make_circles
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.circuit import ParameterVector
from qiskit.primitives import StatevectorSampler

def get_zz_feature_map(n_qubits, data):
    qc = QuantumCircuit(n_qubits)
    qc.h(range(n_qubits))
    for i in range(n_qubits):
        qc.p(2.0 * data[i], i)
    for i in range(n_qubits - 1):
        qc.cx(i, i+1)
        qc.p(2.0 * (np.pi - data[i]) * (np.pi - data[i+1]), i+1)
        qc.cx(i, i+1)
    return qc

def compute_kernel_matrix(X_train, X_test):
    n_samples_1 = len(X_train)
    n_samples_2 = len(X_test)
    n_qubits = X_train.shape[1]
    kernel_matrix = np.zeros((n_samples_1, n_samples_2))
    
    sampler = StatevectorSampler()
    circuits = []
    
    for i in range(n_samples_1):
        for j in range(n_samples_2):
            qc = QuantumCircuit(n_qubits)
            x_i = X_train[i]
            x_j = X_test[j]
            
            fm_i = get_zz_feature_map(n_qubits, x_i)
            fm_j = get_zz_feature_map(n_qubits, x_j)
            
            qc.compose(fm_i, inplace=True)
            qc.compose(fm_j.inverse(), inplace=True)
            qc.measure_all()
            circuits.append(qc)

    # Batch processing for speed
    batch_size = 50
    for k in range(0, len(circuits), batch_size):
        batch = circuits[k:k+batch_size]
        pubs = [(c,) for c in batch]
        job = sampler.run(pubs)
        results = job.result()
        
        for idx, res in enumerate(results):
            global_idx = k + idx
            row = global_idx // n_samples_2
            col = global_idx % n_samples_2
            
            counts = res.data.meas.get_counts()
            zero_string = "0" * n_qubits
            prob = counts.get(zero_string, 0) / sum(counts.values())
            kernel_matrix[row, col] = prob

    return kernel_matrix

X, y = make_circles(n_samples=20, noise=0.05, factor=0.4)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

kernel_train = compute_kernel_matrix(X_train, X_train)
kernel_test = compute_kernel_matrix(X_test, X_train)

svm = SVC(kernel="precomputed")
svm.fit(kernel_train, y_train)

predictions = svm.predict(kernel_test)
accuracy = np.mean(predictions == y_test)

print(f"Accuracy: {accuracy * 100:.2f}%")
print(f"Predictions: {predictions}")
print(f"Actual:      {y_test}")
